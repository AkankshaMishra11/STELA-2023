List<String> expNo = ["1", "2", "3", "4(a)", "4(b)", "5", "6", "7","8(a)","8(b)","9","10"];

List<String> aim = [

  "Write prolog program for solving Tower of Hanoi Problem",
  "Write a Prolog program for solving Monkey-Banana Problem. A hungry monkey is in a room, and he is near the door. The monkey is on the floor. Bananas have been hung from the center of the ceiling of the room. There is a block (or chair) present in the room near the window. The monkey wants the banana, but cannot reach it. How Monkey can get the Banana?",
  "Write a prolog program for your own family tree.",
  "Write a LISP function to compute the nth Fibonacci number",
  "Write a LISP Program to implement Pattern Matching",
  "Solve Farmer, wolf, goat and cabbage problem using LISP",
  "Perform operations on Vector and Matrix using R Programming",
  "Perform operations on Lists, Factors and Data frames using R Programming",
  "Write an R command for displaying the given pie chart and bar chart.",
  "Flow control Statements: 1. Write a R Program to display multiplication table using for loop 2. Write a R Program to Check whether the given number is Armstrong number/not using while loop. 3. Write a R Program to check whether the given year is leap year/not"\n
  "Use airquality dataset to i) Create R boxplot with Notch for the columns Ozone and Month. ii) Create Scatter Plot matrices with four variables : Ozone, Wind, ",
  "Write a program to perform Web Scraping by connecting R to Web Data and built a connection to a web page through URL Conn",

];

List<String> procedure = [
  "The Tower of Hanoi (also called the Tower of Brahma or Lucas' Tower and pyramid puzzle ) is a mathematical game or puzzle consisting of three rods and a number of disks of various diameters, which can slide onto any rod. These rings are of different sizes and stacked upon in an ascending order, i.e. the smaller one sits over the larger one. We mark three towers with name, source, destination and intermediate (only to help moving the disks). The objective of the puzzle is to move the entire stack to the last rod, obeying the following rules: \n Only one disk can be moved among the towers at any given time. \n Only the \"top\" disk can be removed. \n No large disk can sit over a small disk. \nTower of Hanoi puzzle with n disks can be solved in minimum 2^3-1 steps. This presentation shows that a puzzle with 3 disks has taken 2^3-1 = 7 steps. To write an algorithm for Tower of Hanoi, first we need to learn how to solve this problem with lesser amount of disks. If we have only one disk, then it can easily be moved from source to destination peg. The following diagram depicts the starting setup for N=3 disks.The procedure for moving the disks when n = 3 is as follows: \n Move top disk from source to target \n Move top disk from source to intermediate \n Move top disk from target to intermediate \n Move top disk from source to target \n Move top disk from intermediate to source \n Move top disk from intermediate to target \n Move top disk from source to target",
  "The monkey and banana problem is a famous toy problem in artificial intelligence, particularly in logic programming and planning. The ‘monkey world’ always is in some state that can be changed in time. The current state is determined by the positions of the objects. Monkey’s possible actions \n walk on the floor \n push the box around if it is already at the box \n grasp the banana if standing on the box directly under the banana \n climb the box \nThe following few movements can be made in this situation − \n Monkey can reach the block, if both of them are at the same level. Both the monkey and the block are on the floor. \n If the block position is not at the center, then monkey can drag it to the center. \n If monkey and the block both are on the floor, and block is at the center, then the monkey can climb up on the block. So the vertical position of the monkey will be changed. \n When the monkey is on the block, and block is at the center, then the monkey can get the bananas. \nAnother predicate will be canget(). Here we pass a state, so this will perform move predicate from one state to another using different actions, then perform canget() on state 2. When we have reached to the state ‘has>’, this indicates ‘has banana’. We will stop the execution.",
  "Relationship is one of the main features that we have to properly mention in Prolog. These relationships can be expressed as facts and rules. There are various kinds of relationships, of which some can be rules as well. A rule can find out about a relationship even if the relationship is not defined explicitly as a fact. We can define a brother relationship as follows − Two person are brothers, if, \n A and B, both are male. \n They have same father. \n They have same mother. \n A and B are not same. Prolog rule : brother(X,Y):-parent(Z,X),parent(Z,Y),male(X)",
  "In mathematics, the Fibonacci numbers, commonly denoted Fn, form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. F0 = 0, F1 = 1, and Fn = Fn-1 + Fn-2; for n > 1. The sequence is like : 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ",
  "Pattern matching is an important AI methodology. It takes two arguments as input and return T if both matches. It requires both arguments to have same data structure and identical atoms in corresponding posit",
  "A farmer with his wolf, goat, and cabbage arrive at the bank of a river. A boat at the river’s edge is only large enough for the farmer and one of his possessions. The farmer cannot leave the wolf alone with the goat, or the goat alone with the cabbage. Write a program in Lisp to help the farmer cross the river with all of his possessions ",
  "Vectors : Vectors are the most basic R data objects and there are six types of atomic vectors. They are logical, integer, double, complex, character and raw. We can treat a vector as a regular variable. The basic syntax of creating a vector is : v=c(1,2,3) Matrices : Matrices are the R objects in which the elements are arranged in a two-dimensional rectangular layout. They contain elements of the same atomic types. Though we can create a matrix containing only characters or only logical values, they are not of much use. We use matrices containing numeric elements to be used in mathematical calculations. A Matrix is created using the matrix() function. The basic syntax for creating a matrix in R is − matrix(data, nrow, ncol, byrow, dimname) .Following is the description of the parameters used −  data is the input vector which becomes the data elements of the matrix \n  nrow is the number of rows to be created \n ncol is the number of columns to be created \n byrow is a logical clue. If TRUE then the input vector elements are arranged by row \n dimname is the names assigned to the rows and c",
  "Lists : Lists are the R objects which contain elements of different types like − numbers, strings, vectors and another list inside it. A list can also contain a matrix or a function as its elements. List is created using list() function. The basic syntax of creating a list is : list1=list(“red”,”green”,”blue”) Factors : Factors are the data objects which are used to categorize the data and store it as levels. They can store both strings and integers. They are useful in the columns which have a limited number of unique values. Like 'Male' and 'Female' True, False etc. They are useful in data analysis for statistical modeling. Factors are created using the factor() function by taking a vector as input. Data Frames : A data frame is a table or a two-dimensional array-like structure in which each column contains values of one variable and each row contains one set of values from each column. Following are the characteristics of a data frame. \n The column names should be non-empty. \n The row names should be unique. \n The data stored in a data frame can be of numeric, factor or character type. Each column should contain same number of data items.",
  "Pie Chart: A pie-chart is a representation of values as slices of a circle with different colors. The slices are labeled and the numbers corresponding to each slice is also represented in the chart. In R the pie chart is created using the pie() function which takes positive  numbers as a vector input. The additional parameters are used to control labels, color, title etc. The basic syntax for creating a pie-chart using the R is − pie(x, labels, radius, main, col, clockwise) Following is the description of the parameters used − \n– x is a vector containing the numeric values used in the pie chart. \n– labels is used to give description to the slices.\n – radius indicates the radius of the circle of the pie chart.(value between −1 and +1).\n – main indicates the title of the chart.\n – col indicates the color palette. \n– clockwise is a logical value indicating if the slices are drawn clockwise or anti clockwise. Bar Chart: A bar chart represents data in rectangular bars with length of the bar proportional to the value of the variable. R uses the function barplot() to create bar charts. R can draw both vertical and horizontal bars in the bar chart. In bar chart each of the bars can be given different colors. The basic syntax to create a bar-chart in R is − barplot(H, xlab, ylab, main, names.arg, col) Following is the description of the parameters used − \n– H is a vector or matrix containing numeric values used in bar chart. \n– xlab is the label for x axis. – ylab is the label for y axis. – main is the title of the bar chart. – names.arg is a vector of names appearing under each bar. – col is used to give colors to the bars in the",
  "For Loop : A For loop is a repetition control structure that allows you to efficiently write a loop that needs to execute a specific number of times. The basic syntax for creating a for loop statement in R is − for(value in vector){ Statements} R’s for loops are particularly flexible in that they are not limited to integers, or even numbers in the input. We can pass character vectors, logical vectors, lists or expressions. While Loop: The While loop executes the same code again and again until a stop condition is met. The basic syntax for creating a while loop in R is − while(test_expression){ Statements } Here key point of the while loop is that the loop might not ever run. When the condition is tested and the result is false, the loop body will be skipped and the first statement after the while loop will be executed.",
  "Boxplot: Boxplots are a measure of how well distributed is the data in a data set. It divides the data set into three quartiles. This graph represents the minimum, maximum, median, first quartile and third quartile in the data set..The basic syntax to create a boxplot in R is − boxplot(x, data, notch, varwidth, names, main) Following is the description of the parameters used − \n– x is a vector or a formula \n– data is the data frame.\n – notch is a logical value. Set as TRUE to draw a notch. \n– varwidth is a logical value. Set as true to draw width of the box proportionate to the sample size. \n– names are the group labels which will be printed under each boxplot. \n– main is used to give a title to the graph. Scatterplot Matrices: When we have more than two variables and we want to find the correlation between one variable versus the remaining ones we use scatterplot matrix. We use pairs() function to create matrices of scatterplots. Syntax: pairs(formula, data) Following is the description of the parameters used − formula represents the series of variables used in pairs. data represents the data set from which the variables will",
  "Connectin R to Web Data: Many websites provide data for consumption by its users. For example, the WHO provides reports on health and medical information in the form of CSV, txt and XML files. Using R programs, we can programmatically extract specific data from such websites. Packages Used to scrap data from web – rvest, dplyr . They are used to connect to the URL’s, identify required links for the files and download them to the local environment. Connection to a Webpage using URL Connection : The readLines() function can be useful for reading in lines of webpages. Since web pages are basically text files that are stored on a remote server, there is conceptually not much difference between a web page and a local text file. The url() function creates a url connection to a web server.",
];

List<String> algorithm = [
  "\nStep 1 − Move n-1 disks from source to intermediate\nStep 2 − Move nth disk from source to target\nStep 3 − Move n-1 disks from intermediate to target",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
];

List<String> program = [
  "move(1,S,T,_) :- \nwrite('Move top disk from '), write(S), write(' to '), write(T), nl. \nmove(N,S,T,I) :- \nN>1, M is N-1, \nmove(M,S,I,T), \nmove(1,S,T,_), \nmove(M,I,T,S).",
  "move(state(middle,onbox,middle,hasnot), \ngrasp, \nstate(middle,onbox,middle,has)). \nmove(state(P,onfloor,P,H), \nclimb, \nstate(P,onbox,P,H)). \nmove(state(P1,onfloor,P1,H), \npush(P1,P2), \nstate(P2,onfloor,P2,H)). \nmove(state(P1,onfloor,B,H), \nwalk(P1,P2), \nstate(P2,onfloor,B,H)). \ncanget(state(_,_,_,has)). \ncanget(State1) :- \nmove(State1,_,State2), \ncanget(State2)."
  "male(ramesh). male(navneet). male(tanmay). female(saroj). female(poonam). female(saumya). parent(ramesh,navneet). parent(navneet,tanmay). parent(saroj,navneet). parent(poonam,tanmay). parent(navneet,saumya). parent(poonam,saumya). grandparent(X,Y):-parent(X,Z),parent(Z,Y). grandfather(X,Z):-father(X,Y),parent(Y,Z). grandmother(X,Z):-mother(X,Y),parent(Y,Z). mother(X,Y):-parent(X,Y),female(X). father(X,Y):-parent(X,Y),male(X). brother(X,Y):-parent(Z,X),parent(Z,Y),male(X),X\==Y. sister(X,Y):-parent(Z,X),parent(Z,Y),female(X),X\==Y. wife(X,Y):-parent(X,Z),parent(Y,z),female(X),male",
  "(defun fibonacci (N) 'Compute for the Nth Fibonacci Number.' (if (or (zerop N) (= N 1))1 (let ((F1 (fibonacci (- N 1))) (F2 (fibonacci (- N 2)))) (+ F1 F2)))) (print (fibonacci 5)",
  "(defun match (pattern1 pattern2) (cond ( (or (atom pattern1) (atom pattern2)) (match-atom pattern1 pattern2) ) (t (and (match (car pattern1) (car pattern2)) (match (cdr pattern1) (cdr pattern2)) )))) (defun match-atom (pattern1 pattern2) (or (equal pattern1 pattern2) (variable-p pattern1) (variable-p pattern2) )) (defun variable-p (x) (equal x '?)) (write (match '(likes bill wine) '(likes bill wine))) (terpri) (write (match '(likes bill wine) '(likes bill milk))) (terpri) (write (match '(likes bill ?) '(likes bill wine))) (terpri) (write (match '(likes ? wine) '(likes bill ?))) (terpri) (write (match '(likes bill ?) '(likes bill (prolog lisp smalltalk)))) (terpri) (write (match '(likes ?) '(likes bill",
  "(defun solve-fwgc (state goal) (path state goal nil)) ;;; The recursive path algorithm searches the space in a depth first ;;; fashion. (defun path (state goal been-list) (cond ((null state) nil) ((equal state goal) (reverse (cons state been-list))) ((not (member state been-list :test #'equal)) (or (path (farmer-takes-self state) goal (cons state been-list)) (path (farmer-takes-wolf state) goal (cons state been-list)) (path (farmer-takes-goat state) goal (cons state been-list)) (path (farmer-takes-cabbage state) goal (cons state been-list))))))  ;;; These functions define legal moves in the state space. The take ;;; a state as argument, and return the state produced by that operation. (defun farmer-takes-self (state) (safe (make-state (opposite (farmer-side state)) (wolf-side state) (goat-side state) (cabbage-side state)))) (defun farmer-takes-wolf (state) (cond ((equal (farmer-side state) (wolf-side state)) (safe (make-state (opposite (farmer-side state)) (opposite (wolf-side state)) (goat-side state) (cabbage-side state)))) (t nil))) (defun farmer-takes-goat (state) (cond ((equal (farmer-side state) (goat-side state)) (safe (make-state (opposite (farmer-side state)) (wolf-side state) (opposite (goat-side state)) (cabbage-side state)))) (t nil))) (defun farmer-takes-cabbage (state) (cond ((equal (farmer-side state) (cabbage-side state)) (safe (make-state (opposite (farmer-side state)) (wolf-side state) (goat-side state) (opposite (cabbage-side state))))) (t nil))) ;;; These functions define states of the world ;;; as an abstract data type. (defun make-state (f w g c) (list f w g c)) (defun farmer-side ( state ) (nth 0 state)) (defun wolf-side ( state ) (nth 1 state)) (defun goat-side ( state ) (nth 2 state)) (defun cabbage-side ( state ) (nth 3 state)) ;;; The function 'opposite' takes a side and returns the opposite ;;; side of the river. (defun opposite (side) (cond ((equal side 'e) 'w) ((equal side 'w) 'e))) ;;; Safe returns nil if a state is not safe; it returns the state unchanged ;;; if it is safe. (defun safe (state) (cond ((and (equal (goat-side state) (wolf-side state)) (not (equal (farmer-side state) (wolf-side state)))) nil) ((and (equal (goat-side state) (cabbage-side state)) (not (equal (farmer-side state) (goat-side state)))) nil) (t state))) ",
"",
  "",
  "",



];

List<String> result = [
  "The above program gives the required steps to move the disks from the source tower to the target tower using intermediate tower.",
  "The above program finds how monkey can get banana using programming",
  "The above program gives the family relationship between various members of my family",
  "The above program prints the nth fibonacci number of the fibonacci series",
"The above program compares two arguments and return ",
"The above program in Lisp is to help the farmer cross the river with all of his possessions i",
  "The R program successfully performs all the operations on the data types, Vectors and",
  "The R program successfully performs all the operations on the data types, Lists, Factors and",
  "The R program successfully plots pie chart and bar chart with the",
  "The R program successfully used both, for loop and while loop to achieve the ",
  "The R program successfully plots the Boxplot and Scatterplot Matrix with the given air quality data",
  "The R program successfully connects to Web data and also able to read content from a url",


];